{
  "id": "2",
  "title": "Give it a try!",
  "author": "beeceej",
  "body":
    "#[DynamoDB](https://aws.amazon.com/dynamodb/) is awesome; it has a free tier and it's incredibly easy to stand up a table and don't have to deal with any instances. It does have warts though, things like [Not supporting empty strings](https://forums.aws.amazon.com/thread.jspa?threadID=90137). DynamoDB is able to handle heavy write workloads like a champ and hash/range key lookups efficiently. But, you'll quickly run into issues when you need to issue complex queries on multiple data facets. The solution here is multiple indexes (under the hood an Dynamo index is equivalent to a copy of the table, just keyed differently. Multiple indexes become expensive, and don't scale well. If an application needs to scan through a Dynamo Table, it will be *slow* and *expensive*. A much better pattern would be to create a Materialized View of your Dynamo Data in a search index like Solr, or in this case [ElasticSearch](https://www.elastic.co/products/elasticsearch). Luckily Dynamo is awesome and provides a feature called [Dynamo Streams](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html) which allow you to capture table activity in real time, as the activity occurs. Utilizing Dynamo Streams lambda functions and Elasticsearch have proven to be a great pattern for improving Dynamo's Queryability on data without maintaining multiple indexes. This pattern is so useful it has proven useful to abstract this concept out into a Serverless project, which maintains an elasticsearch ingest lambda function. Let's dig into how this function works.\n ##Elasticsearch primer",
  "postedAt": "07/19/2018",
  "updatedAt": "07/19/2018",
  "visible": true
}
