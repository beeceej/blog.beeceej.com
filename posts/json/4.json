{
  "id": "4",
  "title": "Writing a Go interpreter in Go",
  "author": "Brian Jones",
  "postedAt": "August 7th, 2018",
  "updatedAt": "August 12th, 2018",
  "visible": true,
  "body": "\n## Why Interpreters\n\nThe main reason to use an interpreter is an improved workflow. If you're like me then you're always searching for ways to improve working efficiency. Interpreters are one surefire way to improve productivity, and it's all about shortening feedback loops. Shorter feedback loops usually equate to quicker turn around times. Even with Go, which compiles extremely fast, seeing results as you type like in Python or Lisp can be extremely beneficial. Python and lisp are both interpreted and have special tooling built out for this purpose. The draw of LSIP is the interpreter and the rapid feedback loop that evaluating code on the fly gives you. Hell, even Java has a REPL now, and if Java has something like an interpreter there's no reason Go can't have one. At the core of Python and LISP's respective design, is the interpreter which makes an interpreted workflow first class within each languages respective ecosystem. Unfortunately, in general, the compilation process of languages like Java (JVM Bytecode) or Go (Binary) doesn't lend itself naturally to evaluating expressions on the fly. Historically, to get a quick feedback while developing in a compiled language you'd need to execute some combination of the following steps\n\n1.  Write Tests\n2.  Run Tests, and observe behavior\n3.  Make changes to code\n4.  Repeat\n\nThis is a good workflow, but we can do better. This is why interpreters are awesome. Interpreters _abstract_ away the boring parts about testing our code and give us rapid feedback loops as we work. In EMACs and LISP land, that's just a couple key strokes away, my goal is to replicate this in Go.\n\nSo... with software anything is possible? Just because Go is compiled doesn't mean we can't conjure up an interpreter for a compiled language, developers _are wizards_ aren't we?\n\n## Humble Beginnings\n\nSo with the project in mind, I started writing some code.\n\nI have a very loose understanding of what an interpreter is. So as a result my implementation of an interpreter is very loose is. At it's most simple form, I broke down each piece into these components:\n\n- **Interpreter will Accept Some Raw Text:**\n  - Classify the text into functions, expressions, etc.\n  - Store the classified text in memory for later use\n  - Store history of user defined input\n- **Generate code and compile it**\n  - Use previous commands to generate code\n  - Compile & Execute the code\n  - Given some result (Error or success), report back to the user\n- **The interpreter should accept multiple forms of Interaction**\n  - Client-Server\n  - REPL/CLI (enter some text in, press enter, view results)\n  - Communication is decoupled from the core implementation\n\n## An initial REPL\n\nTurns out, building a usable CLI interface to an interpreter is not easy. my initial strategy looked something like this\n\n```go\nconst mainTmpl = `package main\nfunc main() {\n    {{.}}\n    {{ .M }}\n}\n {{ .F }}`\n\nfunc main() {\n    t := template.Must(template.New(\"mainTmpl\").Parse(mainTmpl))\n    t.Execute(os.Stdout, `fmt.Println(\"iGoIsCool\")`)\n    history := make(map[string]string)\n    var instruct In\n    for {\n        fmt.Print(\"\\n$ \")\n        f, err := os.Create(\"exe.go\")\n        if err != nil {\n            panic(err.Error())\n        }\n        defer f.Close()\n        reader := bufio.NewReader(os.Stdin)\n        text, _ := reader.ReadString('\\n')\n        if history[\"a\"] != \"\" {\n            instruct.F = history[\"a\"]\n        }\n        instruct.M = text\n        if err := t.Execute(f, instruct); err != nil {\n            fmt.Println(err.Error())\n        }\n        if f, err := iGo.NewFunction(text); err != nil {\n            fmt.Println(err.Error())\n        } else {\n            history[f.Identifier] = f.Raw\n            for k, v := range history {\n                fmt.Printf(\"%s: %s\\n\", k, v)\n            }\n        }\n        cmd := exec.Command(\"goimports\", \"-w\", \"exe.go\")\n        b, err := cmd.Output()\n        if err != nil {\n            fmt.Println(\"Error calling goimports\", err.Error())\n            continue\n        }\n        fmt.Println(string(b))\n\n        cmd = exec.Command(\"go\", \"run\", \"exe.go\")\n        b, err = cmd.Output()\n        if err != nil {\n            fmt.Println(\"Error calling go run\", err.Error())\n            continue\n        }\n        fmt.Println(fmt.Sprintf(\">> %s\", string(b)))\n\n        os.Remove(path)\n    }\n}\n```\n\nThis is what I call some ugly Code! That's ok! it worked.... kind of\n\n- There's a loop, processing some user input\n- A template which generates the boiler plate of an executable go program\n- Some exec.Command().Outputs() which:\n  - Run Goimports on the generated Go code (Thank god that's part of the Go toolchain)\n  - run the generated code, and reports the output back\n\nThis quick 30 min hack was enough validation to continue working. So I decided to begin work on parsing out functions from raw user input\n\n## Parsing Functions\n\nAt the moment of writing this, I'm parsing the function by regular expressions.\n\nThe in memory representation of a function is:\n\n```go\ntype Function struct {\n    // Raw, the raw input which was determined to be a function\n    Raw string\n\n    // Identifier, the identifier of the function.\n    // For example:\n    // func a() {\n    //\n    // }\n    // Identifier would = a\n    Identifier string\n\n    // Params is a raw string which identifies the parameters of the function\n    Params string\n\n    // Return is the return signature of the function\n    Return string\n}\n```\n\nAnd I have some hacked together regexes to parse each piece of a function:\n\n```go\nconst (\n    // holds double duty for classifying, and extracting functions from raw text\n    isFunctionExpr regexpType = iota\n    identifierExpr\n    argsExpr\n    returnExpr\n)\n\nvar expressions = map[regexpType]*regexp.Regexp{\n    isFunctionExpr: regexp.MustCompile(`func \\(?.*\\)?\\{\\n?(.*|\\s|\\S)*?(\\})`),\n    identifierExpr: regexp.MustCompile(`(func .* \\(|func .*?)\\(`),\n    argsExpr:       regexp.MustCompile(`\\((.*?)\\)`),\n    returnExpr:     regexp.MustCompile(`\\) .* {`),\n}\n```\n\nUsing the 4 above expression I'm able to piece together each part of a function and store it in memory as a Map\n\nFor example,\n\n```go\nisFunctionExpr: regexp.MustCompile(`func \\(?.*\\)?\\{\\n?(.*|\\s|\\S)*?(\\})`),\n```\n\nwill classify some text as **_is a function_** or **_is not a function_**\n\nfor instance:\n\n```go\nfunc hello() int {\n\n}\n```\n\n**would** parse, while\n\n```go\nfunction() string {\n}\n```\n\n**wouldn't** parse\n\nSimilarly, the other 3 expressions are able to parse different parts of a function. I'm admittedly not the best at regular expressions so I'm sure there are cleaner ways if coming to the same solution. So this likely won't stay the same forever. But it works pretty well for now.\n\nAfter a couple days of hacking on iGo I was able to classify functions, store them in memory, look them up, and generate them on the fly. And as a bonus, since Go already has a great ecosystem Goimports is able to look up references to 3rd party packages; that's awesome!\n\n## Read, Interpret, Eval\n\nThe Interpreter struct is very basic. It holds a map of references to functions, and a history of text the interpreter has seen.\n\n```go\n// Interpreter houses the function references and input history\ntype Interpreter struct {\n    Functions map[string]*parse.Function\n    History   []string\n}\n```\n\nEvery time a function is recognized as such, it will be placed in Interpreter.Functions (keyed by its ID), that looks like this:\n\n```go\n// Interpret will take some text and\n// Classify it as either an expression or a function\n// If it is a function it will store the reference of the Function in a map\n// If the text is classified as an expression, it will evaluate the expression,\n// using the function reference map if needed\nfunc (i *Interpreter) Interpret(text string) {\n    if i.Functions == nil {\n        i.Functions = make(map[string]*parse.Function)\n    }\n    i.History = append(i.History, text)\n    t := i.classify(text)\n    for _, tv := range t {\n        switch v := tv.(type) {\n        case *parse.Function:\n            i.Functions[v.Identifier] = v\n            fmt.Printf(\"# %s\\n\", v.String())\n            break\n        case *parse.Expression:\n            fmt.Printf(\">> %s\\n\", text)\n            i.Eval(text)\n            break\n        }\n    }\n}\n```\n\nBy default, we don't eval function declarations right away, they just sit there until they're needed\n\nOnce the user invokes the interpreter with a function they declared earlier, the interpreter will then attempt to eval the function.\n\n```go\ncase *parse.Expression:\n            fmt.Printf(\">> %s\\n\", text)\n            i.Eval(text)\n            break\n        }\n```\n\nAnd the eval code is the same in my 30 min hacked together program, just refactored to use the core interpreter implementation\n\n## Decoupling the Interpreter From Input\n\nWhen a started this project I began with a simple Terminal based input system. That worked, relatively well but wasn't much fun. I quickly outgrew that and the quickest way to stress test my function parsing was to allow a more robust transfer mechanism from _User_ to _Interpreter_. I wrote a simple HTTP Server which accepts requests and forwards them to the interpreter. Then spits out the result of the code which was interpreted.\n\nThat meant I needed to refactor; I began splitting every piece into a module and I ended up with a package structure like\n\n- pkg\n  - parse\n  - interpreter\n\nparse handles the text parsing and classification, and interpreter utilizes the parsed data to implement the interpreter. Once that was done it was easy to accept Client Server Communication.\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n\n    \"github.com/beeceej/iGo/pkg/interpreter\"\n    \"github.com/davecgh/go-spew/spew\"\n)\n\nfunc main() {\n    i := interpreter.Interpreter{}\n    http.HandleFunc(\"/interpret\", func(w http.ResponseWriter, r *http.Request) {\n        b, _ := ioutil.ReadAll(r.Body)\n        defer r.Body.Close()\n        var m struct {\n            Text string `json:\"text\"`\n        }\n        json.Unmarshal(b, &m)\n        i.Interpret(m.Text)\n    })\n\n    if err := http.ListenAndServe(\":9999\", nil); err != nil {\n        fmt.Println(err.Error())\n        spew.Dump(i)\n    }\n}\n```\n\nNotice the last line, if the server fails for any reason, we are able to print out the exact state of the interpreter at the time of crash... (`spew.Dump(i)`). This is a very powerful concept and lends itself very nicely to programmatic use! For instance one could read from the file system to hydrate state. One could declare a set of default functions in a config file.\n\n## Integrations\n\nSince we're able to run the interpreter as a server, we can build many unique clients for it. Just write a plugin for your editor of choice and you can have much the same functionality that interpreted language users use and love on a daily basis.\n\nKeep in mind this project is under active development, What's written here will likely change! to follow the development keep an eye out for further posts! Or, if you're interested in iGo you can follow the development [here](https://github.com/beeceej/iGo).\n\nPart 1 of **_Writing a Go Interpreter in Go_**\n",
  "hash": "41459f977613b357d861135155529df7"
}