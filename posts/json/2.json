{
  "id": "2",
  "title": "Writing a Go interpreter in Go",
  "author": "Brian Jones",
  "postedAt": "August 7th",
  "updatedAt": "August 7th, 2018",
  "visible": "true",
  "body": "\n## Why Interpreters\n\nThe main reason to use an interpreter is an improved workflow. Python has one, iPython is awesome. The draw of LISP's are the interpreters and the rapid feedback loop that evaluating code on the fly gives you. Hell, even Java has a REPL now; even if I haven't used it yet. Python and Lisp are for the sake of this discussion interpreted languages. At the core of each respective design, is the interpreter. In general, the compilation process of languages like Java (JVM Bytecode) or Go (Binary) doesn't lend itself naturally to evaluating expressions on the fly. Historically, to get a quick feedback while developing in a compiled language goes like this:\n\n1.  Write Tests\n2.  Run Tests, and observe behavior\n3.  Make changes to code\n\nThis is a good workflow, but we can do better. This is why interpreters are awesome. Interpreters abstract away the boring parts about testing our code and give us a rapid feed back loop as we work. In EMACs and LISP land, that's just a couple key strokes away.\n\nSo... with software anything is possible? Just because Go is compiled doesn't mean we can't conjure up an interpreter for a compiled language, developers _are wizards_ aren't we?\n\n## Humble Beginnings\n\nSo with the project in mind, I started writing some code.\n\nI have a very loose understanding of what an interpreter is. So as a resultI also have a very loose idea of what the interpreter is. At it's most simple form, I broke down each piece of the interpreter into this:\n\n- **Accept some raw text and with the input:**\n  - Classify the text into functions, expressions, etc.\n  - store references to the text\n  - store some history of the text\n- **Generate code and compile it**\n  - Use the history from previous commands to generate the necessary code\n  - Generate the code, Compile the code, execute the code.\n  - If there is a result, report back to the user\n- **The interpreter should accept multiple forms of communication**\n  - Client Server relationship\n  - REPL/CLI (enter some text in, press enter, view results)\n  - Communication is decoupled from the core implementation\n\n## An initial REPL\n\nTurns out, building a usable CLI interface to an interpreter is not easy. my initial strategy was something along these lines\n\n```go\nconst mainTmpl = `package main\nfunc main() {\n    {{.}}\n    {{ .M }}\n}\n {{ .F }}`\n\nfunc main() {\n    t := template.Must(template.New(\"mainTmpl\").Parse(mainTmpl))\n    t.Execute(os.Stdout, `fmt.Println(\"iGoIsCool\")`)\n    history := make(map[string]string)\n    var instruct In\n    for {\n        fmt.Print(\"\\n$ \")\n        f, err := os.Create(\"exe.go\")\n        if err != nil {\n            panic(err.Error())\n        }\n        defer f.Close()\n        reader := bufio.NewReader(os.Stdin)\n        text, _ := reader.ReadString('\\n')\n        if history[\"a\"] != \"\" {\n            instruct.F = history[\"a\"]\n        }\n        instruct.M = text\n        if err := t.Execute(f, instruct); err != nil {\n            fmt.Println(err.Error())\n        }\n        if f, err := iGo.NewFunction(text); err != nil {\n            fmt.Println(err.Error())\n        } else {\n            history[f.Identifier] = f.Raw\n            for k, v := range history {\n                fmt.Printf(\"%s: %s\\n\", k, v)\n            }\n        }\n        cmd := exec.Command(\"goimports\", \"-w\", \"exe.go\")\n        b, err := cmd.Output()\n        if err != nil {\n            fmt.Println(\"Error calling goimports\", err.Error())\n            continue\n        }\n        fmt.Println(string(b))\n\n        cmd = exec.Command(\"go\", \"run\", \"exe.go\")\n        b, err = cmd.Output()\n        if err != nil {\n            fmt.Println(\"Error calling go run\", err.Error())\n            continue\n        }\n        fmt.Println(fmt.Sprintf(\">> %s\", string(b)))\n\n        os.Remove(path)\n    }\n}\n```\n\nThis is what I call some ugly Code!\n\n- There's a loop, processing some user input\n- A template which generates the boiler plate of an executable go program\n- Some exec.Command().Outputs() which:\n  - Run Goimports on the generated Go code (Thank god that's part of the Go toolchain)\n  - run the generated code, and reports the output back\n\nThis quick 30 min hack was enough validation to continue working. So I began working on parsing out go functions from raw user input\n\n## Parsing Functions\n\nAt the moment of writing this, I'm parsing the function by regular expressions.\n\nThe in memory representation of a function is:\n\n```go\ntype Function struct {\n    // Raw, the raw input which was determined to be a function\n    Raw string\n\n    // Identifier, the identifier of the function.\n    // For example:\n    // func a() {\n    //\n    // }\n    // Identifier would = a\n    Identifier string\n\n    // Params is a raw string which identifies the parameters of the function\n    Params string\n\n    // Return is the return signature of the function\n    Return string\n}\n```\n\nAnd I have some hacked together regexes to parse each piece of a function:\n\n```go\nconst (\n    // holds double duty for classifying, and extracting functions from raw text\n    isFunctionExpr regexpType = iota\n    identifierExpr\n    argsExpr\n    returnExpr\n)\n\nvar expressions = map[regexpType]*regexp.Regexp{\n    isFunctionExpr: regexp.MustCompile(`func \\(?.*\\)?\\{\\n?(.*|\\s|\\S)*?(\\})`),\n    identifierExpr: regexp.MustCompile(`(func .* \\(|func .*?)\\(`),\n    argsExpr:       regexp.MustCompile(`\\((.*?)\\)`),\n    returnExpr:     regexp.MustCompile(`\\) .* {`),\n}\n```\n\nUsing the 4 above expression I'm able to piece together each part of a function and store it memory, keyed by its identifier.\n\nFor example,\n\n```go\nisFunctionExpr: regexp.MustCompile(`func \\(?.*\\)?\\{\\n?(.*|\\s|\\S)*?(\\})`),\n```\n\nwill classify some text as **_is a function_** or **_is not a function_**\n\nfor instance:\n\n```go\nfunc hello() int {\n\n}\n```\n\n**would** parse, while\n\n```go\nfunction() string {\n}\n```\n\n**wouldn't** parse\n\nSimilarly, the other 3 expressions are able to parse different parts of a function. I'm admittedly not the best at regular expressions so I'm sure there are cleaner ways if coming to the same solution. So this likely won't stay the same forever. But it works pretty well for now. I was very surprised to find that the ability to parse functions quickly gave the ability to do lots of cool things.\n\nAfter a couple days of hacking on iGo I was able to classify functions, store them in memory, look them up, and generate them on the fly. And as a bonus, since Goimport is so cool, iGo is able to reference 3rd party libraries as well\n\n## Read Interpret Eval\n\nThe Interpreter struct is very basic. It holds a map of references to functions, and a history of text the interpreter has seen.\n\n```go\n// Interpreter houses the function references and input history\ntype Interpreter struct {\n    Functions map[string]*parse.Function\n    History   []string\n}\n```\n\nEvery time a function is recognized as such, it will be placed in Interpreter.Functions (keyed by its ID), that looks like this:\n\n```go\n// Interpret will take some text and\n// Classify it as either an expression or a function\n// If it is a function it will store the reference of the Function in a map\n// If the text is classified as an expression, it will evaluate the expression,\n// using the function reference map if needed\nfunc (i *Interpreter) Interpret(text string) {\n    if i.Functions == nil {\n        i.Functions = make(map[string]*parse.Function)\n    }\n    i.History = append(i.History, text)\n    t := i.classify(text)\n    for _, tv := range t {\n        switch v := tv.(type) {\n        case *parse.Function:\n            i.Functions[v.Identifier] = v\n            fmt.Printf(\"# %s\\n\", v.String())\n            break\n        case *parse.Expression:\n            fmt.Printf(\">> %s\\n\", text)\n            i.Eval(text)\n            break\n        }\n    }\n}\n```\n\nBy default, we don't eval function declarations right away, I'm just storing them in memory. They'll sit there\n\n- until\n  - The session ends (program exits)\n  - The user requests to interpret a function which has been defined earlier.\n  - At that point the interpreter evals, utilizing the functions declared earlier\n\n```go\ncase *parse.Expression:\n            fmt.Printf(\">> %s\\n\", text)\n            i.Eval(text)\n            break\n        }\n```\n\nAnd the eval code is the same in my 30 min hacked together program, just refactored to use the interpreter which is the core implementation.\n\n## Decoupling the Interpreter From Input\n\nWhen a started this project I began with a simple Terminal based input system. That worked, relatively well but wasn't much fun. I quickly outgrew that and the quickest way to stress test my function parsing was to allow a more robust transfer mechanism from _User_ to _Interpreter_. I wrote a simple HTTP Server which accepts requests and forwards them to the interpreter. Then spits out the result of the code which was interpreted.\n\nThat meant I needed to refactor; I began splitting every piece into a module and I ended up with a package structure like\n\n- pkg\n  - parse\n  - interpreter\n\nparse handles the text parsing and classification, and interpreter utilizes the parsed data to implement the interpreter. Once that was done it was easy to accept Client Server Communication.\n\n```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n\n    \"github.com/beeceej/iGo/pkg/interpreter\"\n    \"github.com/davecgh/go-spew/spew\"\n)\n\nfunc main() {\n    i := interpreter.Interpreter{}\n    http.HandleFunc(\"/interpret\", func(w http.ResponseWriter, r *http.Request) {\n        b, _ := ioutil.ReadAll(r.Body)\n        defer r.Body.Close()\n        var m struct {\n            Text string `json:\"text\"`\n        }\n        json.Unmarshal(b, &m)\n        i.Interpret(m.Text)\n    })\n\n    if err := http.ListenAndServe(\":9999\", nil); err != nil {\n        fmt.Println(err.Error())\n        spew.Dump(i)\n    }\n}\n```\n\nNotice the last line, if the server fails for any reason, we are able to print out the exact state of the interpreter at the time of crash... (`spew.Dump(i)`). That is powerful, we could hydrate the Interpreter state from any source. Network. FileSystem. CLI Flags.\n\n## Integrations\n\nSince we're able to run the interpreter as a server, we can build many unique clients for it. Editor integrations are fun, and essential to the usability of the interpreter, so here's how that might look in VSCode.\n\nIf you're interested in iGo you can find the project [here](https://github.com/beeceej/iGo)\n\nPart 1 of **_Writing a Go Interpreter in Go_**\n",
  "hash": "232bc97ea6160815aab3515a286f8ccb"
}